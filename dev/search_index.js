var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DemoActions","category":"page"},{"location":"#DemoActions","page":"Home","title":"DemoActions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DemoActions]","category":"page"},{"location":"#DemoActions.DemoActions","page":"Home","title":"DemoActions.DemoActions","text":"Learning repo for testing various CI and benchmarking tools.\n\nMainly benchmarking my naive ForwardDiff implementation and Dormand-Prince solver on models I find interesting.\n\nWorking through Mathematical Physiology by James Keener and Biomolecular Feedback Systems by Murray.\n\n\n\n\n\n","category":"module"},{"location":"#DemoActions.DP5Cache","page":"Home","title":"DemoActions.DP5Cache","text":"Dummy struct for the Dormand-Prince tableau\n\n\n\n\n\n","category":"type"},{"location":"#DemoActions.MyProbInplace","page":"Home","title":"DemoActions.MyProbInplace","text":"This struct is passed to mysolve.\n\nfields:\n\nalg\nf!\nu0\ntspan\ndt\np\n\n\n\n\n\n","category":"type"},{"location":"#DemoActions.bistable_gene_circuit!-NTuple{4,Any}","page":"Home","title":"DemoActions.bistable_gene_circuit!","text":"Example 3.2 (Bistable gene circuit) - Murray\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.dp5!-NTuple{6,Any}","page":"Home","title":"DemoActions.dp5!","text":"dp5!(m, f, u0, tspan, dt, p)\n\nExplicit Dormand-Prince method. Fixed dt. Non-allocating for the solves. Allocates the intermediate f calls though.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.dp5-NTuple{5,Any}","page":"Home","title":"DemoActions.dp5","text":"dp5(f, u0, tspan, dt, p)\n\nUses dp5! to solve f and store in m.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.dp5_cache-Tuple{}","page":"Home","title":"DemoActions.dp5_cache","text":"dp5_cache()\n\nallocates the DP5 tableau.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.dp5_inplace!-NTuple{6,Any}","page":"Home","title":"DemoActions.dp5_inplace!","text":"dp5_inplace!(m, f!, u0, tspan, dt, p)\n\nExplicit Dormand-Prince method. Fixed dt.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.eulers_inplace_f!-NTuple{6,Any}","page":"Home","title":"DemoActions.eulers_inplace_f!","text":"eulers_inplace_f!(m, f!, u0, tspan, dt, p)\n\nNon-allocating explicit first order method. Fixed dt.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.lotka!-NTuple{4,Any}","page":"Home","title":"DemoActions.lotka!","text":"lotka!(du, u, p, t)\n\nlotka-volterra, inplace \n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.midpoint!-NTuple{6,Any}","page":"Home","title":"DemoActions.midpoint!","text":"midpoint!(m, f, u0, tspan, dt, p)\n\nExplicit second order method. Fixed dt. Allocates for intermediate k values. This means f does not return nothing.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.midpoint_inplace_f!-NTuple{6,Any}","page":"Home","title":"DemoActions.midpoint_inplace_f!","text":"midpoint_inplace_f!(m, f, u0, tspan, dt, p)\n\nExplicit second order method. Fixed dt.\n\nTODO: have du allocated beforehand, so that this function has zero allocations.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.mysolve-NTuple{5,Any}","page":"Home","title":"DemoActions.mysolve","text":"mysolve(alg, f, u0, tspan, dt; p=nothing)\n\nAllocating solve.  The difference between mysolve and mysolve_inplace is  mysolve expects f to return an array, not mutate one.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.mysolve_inplace-NTuple{5,Any}","page":"Home","title":"DemoActions.mysolve_inplace","text":"mysolve_inplace(alg!, f!, u0, tspan, dt; p=nothing)\n\nNon-allocating solve. The difference between mysolve and mysolve_inplace is  mysolve expects f to return an array, not mutate one.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.mysolve_inplace-Tuple{MyProbInplace}","page":"Home","title":"DemoActions.mysolve_inplace","text":"mysolve_inplace(prob::MyProbInplace)\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.negative_autoregulation!-NTuple{4,Any}","page":"Home","title":"DemoActions.negative_autoregulation!","text":"Example 3.4 (Negative autoregulation) - Murray\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.phosphorylation_cycle!-NTuple{5,Any}","page":"Home","title":"DemoActions.phosphorylation_cycle!","text":"Example 3.5 (Phosphorylation cycle) - Murray \n\nZ + X -> Z + X* Y + X* -> Y + X X + X* = Xtot Ytot = c\n\nNotice that in this example there is a fixed amount of Xtot and Ytot.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.rk4!-NTuple{6,Any}","page":"Home","title":"DemoActions.rk4!","text":"rk4!(m, f, u0, tspan, dt, p)\n\nExplicit fourth-order Runge-Kutta method. Fixed dt. m is mutated inplace, but f is not an in-place function.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.rk4_inplace_f!-NTuple{6,Any}","page":"Home","title":"DemoActions.rk4_inplace_f!","text":"rk4_inplace_f!(m, f!, u0, tspan, dt, p)\n\nExplicit fourth-order Runge-Kutta method. Fixed dt. m is mutated inplace and f is an in-place function.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.rk4_inplace_f_prealloc_k!-NTuple{6,Any}","page":"Home","title":"DemoActions.rk4_inplace_f_prealloc_k!","text":"rk4_inplace_f_prealloc_k!(m, f!, u0, tspan, dt, p)\n\nExplicit fourth-order Runge-Kutta method. Fixed dt. m is mutated inplace and f is an in-place function.\n\nThe difference with the other rk4 methods is that  the k values are allocated before the loop.\n\nI want to see which of these is fastest.\n\n\n\n\n\n","category":"method"},{"location":"#DemoActions.transcriptional_component!-NTuple{4,Any}","page":"Home","title":"DemoActions.transcriptional_component!","text":"Example 3.1 (Transcriptional component)\n\n\n\n\n\n","category":"method"}]
}
